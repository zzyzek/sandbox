Hi I'm Zzyv Zzyzek

I'm here to present Punch Out Model Synthesis, A Stochastic algorithm for
constriant based tiling generation.

I'm just going to get right into it.

---

Just as a quick overview,

Punch Out Model Synthesis is a constraint based tiling generation algorithm
that

works on large grids

has minimal setup requirements

and has resiliance to contradictions.

---

or put another way, create a really huge map without using a terabyte of ram.

---

First some definitions

a grid is composed of cells

where each cell be in a superposition of up to d tiles

and we're given tile constraints in each of the dimension directions.

For example, the graph on the right is meant to represent the adjacency
constraints for a particular tile set and an example placement of those
tiles respecting the constraints.

---

So the problem we're trying to solve is the constraint based tiling generation
problem.

That is, find a valid grid realizaion, subject to the tile constraints

where a realization is a single tile placement at every cell location, subject to the
tile constraints.

---

Just some more definitions that will be needed later:

We call a region of cells arc consist
if every tile in every cell has a valid neighbor in
each direction.

If a tile doesn't have a valid neighbor in some direction,
we know it can't be part of any realization because there's no
neighbor to pair up with it.

---

This gives us the basis for a constraint propagation algorithm
by noticing we can remove a tile from a cell's list of available
tiles if it doesn't have a valid neighbor.

Removing that tile might have implications for tiles in cells
around it, so the process of propagating thos implications of
a tile removal by potentially removing neighboring tiles, and
so on, is constraint propagation.

We do that process until we can't remove any more tiles or
we get into a contradiction, where a contradiction is
defined as a cell that has no more valid tiles.

---

Some last definitions before we move on,

a block level solver keeps full arc consistency of the grid its working on

and a grid level sovler keeps minimal information for the entire grid,
only needing resources primarily with the sub regions, or blocks, that it
chooses.

Maintaining arc consistency, depending on the algorithm, can be resource
intensive, so being able to work in sub blocks is desirable to limite
resource use, if needed.

---

### Related work

---

There's a lot of work in this area but I'm only going to focus
on some algorithms and concepts that are most directly related to POMS.

POMS is designed to overcome the limitations of other algorithms while
keeping their features.

In particular, WFC is a "one-shot" solver, failing as soon as a contradiction
is encountered, requiring a restart of the whole search.

BMS adds a stochastic backtracking method by reverting small regions
back to an indeterminite state around a found contradiction but, like
WFC, is a block level solver, so keeps the grid it's working on
in an arc consistent state, sometimes with large resource requirements
to maintain that arc consistency.

MMS gets around the memory requirements by starting from a fully
resolved state and working in blocks.
Because it's fully resolved, there's only one tile that needs to be
kept at each grid cell location and MMS makes progress by picking out
small blocks and incorporating them back in if they successfully resolve.


Because the block size can be smaller than some feature size, or global
constraint, MMS can get trapped in a basin of solution space, not being
able to break out and find other solutions that would otherwise be available.

As I'll go into in a moment, POMS addresses the limitations of each of these algorithms with the exception
of guaranteeing a solution, like MMS does.
I suspect maintining a full resolution through single block level alterations
is mutually exclusive with maintaining the ergodic condition, but I'm not
sure.

---

A fundamental concept for why POMS has a hope of working comes from
Hoetzlein's just math project where the idea of tile influence or tile
correlation is introduced.

The intuition is that if we fix a tile at a cell location and ask how much
affect does it have over other tiles at cell locations very far away.
If the influence is negligeable, then we know we can make progress in small
isolated regions without worrying about undoing progress in other regions.

As a heuristic to quantify this tile influence, Hoetzlen's just math project
introduced the tile arc consistent correlation length.

---

The idea is pretty straight forward:

take a block in isolation,

set it to an indeterminate state

fix a tile at center

take the bounding box that encompases all cells that were altered from the
constraint propagation

then repeat for all tiles

The maximum of all the minimum bounding boxes is the tile arc consistent
correlation length.

The TACCL is a rough heuristic and doesn't fully encapsulate tile correlation
but it has the benefit of being quantifiable and easily calculable so that we
can start to get a sense for what the "characteric length" of the tile
constraints are.

In particular, it helps us make guesses about how big the block size should
be, with block sizes smaller than the correlation length running the risk of
getting trapped in a local minima.

---


