// LICENSE: CC0
//
// To the extent possible under law, the person who associated CC0 with
// this project has waived all copyright and related or neighboring rights
// to this project.
//     
// You should have received a copy of the CC0 legalcode along with this
// work. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
//

var DEBUG_LEVEL = 0;

var fs = require("fs");

function read_xsb(fn) {
  let lines = fs.readFileSync(fn, "utf8").replace( /\r/g, '').split("\n");;

  let levels = [];
  let level = [];

  let level_info = [];

  let max_width = 0;
  let height = 0;

  for (let line_no=0; line_no<lines.length; line_no++) {

    let line = lines[line_no].replace( /^ *$/, '' );

    if (line.length == 0) {
      if (level.length > 0) {
        levels.push({"level":level.join("\n"), "width": max_width, "height":level.length, "info": level_info});
      }
      level = [];
      max_width = 0;
      height = 0;

      level_info = [];
      continue;
    }

    if ((line[0] == '#') || line[0] == ' ') {
      if (line.length > max_width) {
        max_width = line.length;
      }

      level.push(line);
      continue;
    }

    level_info.push(line);
  }
  if (level.length > 0) { levels.push({"level":level.join("\n"), "width":max_width, "height":level.length}); }

  // normalize levels
  //   pad ends with walls
  //   convert empty spaces outside of playable region to walls
  //
  //   this is done via a flood fill of the interior region,
  //   stored in `level_fill`, and then the level is padded
  //   with walls for every element that wasn't affected by
  //   the flood.
  //

  for (let i=0; i<levels.length; i++) {
    let level_rows = levels[i].level.split("\n");

    let H = levels[i].height;
    let W = levels[i].width;

    let level = [];
    for (let h=0; h<H; h++) {
      level.push( level_rows[h].split("") );
      while (level[h].length < W) {
        level[h].push('#');
      }
    }

    let dyx = [[0,1],[0,-1],[1,0],[-1,0]];
    let lq = [];

    // copy to level_fill to do the flood fill
    //
    let level_fill = [];
    for (let y=0; y<H; y++) {
      level_fill.push([]);
      for (let x=0; x<W; x++) {
        level_fill[y].push( level[y][x] );
      }
    }

    // start the flood fill at the player origin point
    //
    for (let y=0; y<H; y++) {
      for (let x=0; x<W; x++) {
        if ((level_fill[y][x] == '@') ||
            (level_fill[y][x] == '+')) {

          level_fill[y][x] = '#';

          for (let idyx=0; idyx<dyx.length; idyx++) {
            let dy = dyx[idyx][0];
            let dx = dyx[idyx][1];

            if ( ((x+dx) >= 0) && ((x+dx) < W) &&
                 ((y+dy) >= 0) && ((y+dy) < H) ) {
              if (level_fill[y+dy][x+dx] != '#') {
                lq.push( [y+dy,x+dx] );
              }
            }
          }

        }
      }
    }

    // pop the queue, taking the position
    // if the position has a wall, continue
    // otherwise go to each non-wall neighbor and
    // add to queue.
    //
    while (lq.length > 0) {
      let p = lq.pop();

      let y = p[0];
      let x = p[1];

      if (level_fill[y][x] == '#') { continue; }


      level_fill[y][x] = '#';

      for (let idyx=0; idyx<dyx.length; idyx++) {
        let dy = dyx[idyx][0];
        let dx = dyx[idyx][1];

        if ( ((x+dx) >= 0) && ((x+dx) < W) &&
             ((y+dy) >= 0) && ((y+dy) < H) ) {
          if (level_fill[y+dy][x+dx] != '#') {
            lq.push( [y+dy,x+dx] );
          }
        }
      }

    }

    for (let y=0; y<H; y++) {
      for (let x=0; x<W; x++) {
        if ((level_fill[y][x] == ' ') && (level[y][x] == ' ')) {
          level[y][x] = '#';
        }
      }
    }

    let _rows = [];
    let _fill_rows = [];
    for (let h=0; h<H; h++) {
      _rows.push( level[h].join("") );
      _fill_rows.push( level_fill[h].join("") );
    }

    if (DEBUG_LEVEL > 1) {
      console.log(">>>");
      console.log("orig:");
      console.log(_rows.join("\n"));
      console.log("---");
      console.log("fill:");
      console.log(_fill_rows.join("\n"));
      console.log("<<<");
    }

    levels[i].level = _rows.join("\n");
  }

  if (DEBUG_LEVEL > 0) {
    for (let i=0; i<levels.length; i++) {
      console.log(";-----", i, levels[i].width, levels[i].height);
      console.log(levels[i].level);
    }
  }

  return levels;
}

function main() {

  let base_dir = "../data/sokobano/Large Test Suite";
  let fns = [
    "Aymeric_Du_Peloux_282.xsb",
    "Grigr2001_100.xsb",
    "Grigr2002_40.xsb",
    "GrigrSpecial_40.xsb",
    "Holland_81.xsb",
    "Microban_155.xsb",
    "Microban II_135.xsb",
    "Sasquatch_50.xsb",
    "Sasquatch II_50.xsb",
    "Sasquatch_III_50.xsb",
    "Sasquatch_IV_50.xsb",
    "Sasquatch_V_50.xsb",
    "Sasquatch_VI_50.xsb",
    "Sasquatch_VII_50.xsb",
    "SokEvo_107.xsb",
    "SokHard_163.xsb",
    "Sven_1623.xsb",
    "XSokoban_90.xsb",
    "Yoshio_Murase_Autogenerated_52.xsb",
    "Yoshio Murase_Handmade_54.xsb"
  ];

  let data = {};

  for (let fn_idx in fns) {
    let fn = base_dir + "/" + fns[fn_idx];
    let level_lib = read_xsb(fn);

    let name = fn;
    name = name.replace( /\.xsb/, '' );
    name = name.replace( /^.*\//, '' );

    data[name] = level_lib;
  }

  console.log( JSON.stringify(data) );
}

main();

