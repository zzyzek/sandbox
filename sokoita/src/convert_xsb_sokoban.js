// LICENSE: CC0
//
// To the extent possible under law, the person who associated CC0 with
// this project has waived all copyright and related or neighboring rights
// to this project.
//     
// You should have received a copy of the CC0 legalcode along with this
// work. If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.
//

var DEBUG_LEVEL = 0;

var fs = require("fs");

function read_xsb(fn) {
  let lines = fs.readFileSync(fn, "utf8").replace( /\r/g, '').split("\n");;

  let levels = [];
  let level = [];

  let level_info = [];

  let max_width = 0;
  let height = 0;

  for (let line_no=0; line_no<lines.length; line_no++) {

    let line = lines[line_no].replace( /^ *$/, '' );

    if (line.length == 0) {
      if (level.length > 0) {
        levels.push({"level":level.join("\n"), "width": max_width, "height":level.length, "info": level_info});
      }
      level = [];
      max_width = 0;
      height = 0;

      level_info = [];
      continue;
    }

    if ((line[0] == '#') || line[0] == ' ') {
      if (line.length > max_width) {
        max_width = line.length;
      }

      level.push(line);
      continue;
    }

    level_info.push(line);
  }
  if (level.length > 0) { levels.push({"level":level.join("\n"), "width":max_width, "height":level.length}); }

  // normalize levels
  //   pad ends with walls
  //   convert empty spaces outside of playable region to walls
  //
  for (let i=0; i<levels.length; i++) {
    let level_rows = levels[i].level.split("\n");

    let H = levels[i].height;
    let W = levels[i].width;

    let level = [];
    for (let h=0; h<H; h++) {
      level.push( level_rows[h].split("") );
      while (level[h].length < W) {
        level[h].push('#');
      }
    }

    for (let h=0; h<H; h++) {
      for (let w=0; w<W; w++) {
        if (level[h][w] == '#') { break; }
        if (level[h][w] == ' ') { level[h][w] = '#'; }
      }

      for (let w=(W-1); w>=0; w--) {
        if (level[h][w] == '#') { break; }
        if (level[h][w] == ' ') { level[h][w] = '#'; }
      }
    }

    for (let w=0; w<W; w++) {
      for (let h=0; h<H; h++) {
        if (level[h][w] == '#') { break; }
        if (level[h][w] == ' ') { level[h][w] = '#'; }
      }

      for (let h=(H-1); h>=0; h--) {
        if (level[h][w] == '#') { break; }
        if (level[h][w] == ' ') { level[h][w] = '#'; }
      }
    }

   
    let _rows = [];
    for (let h=0; h<H; h++) {
      _rows.push( level[h].join("") );
    }

    levels[i].level = _rows.join("\n");

  }

  if (DEBUG_LEVEL > 0) {
    for (let i=0; i<levels.length; i++) {
      console.log(";-----", i, levels[i].width, levels[i].height);
      console.log(levels[i].level);
    }
  }

  return levels;
}

function main() {

  let base_dir = "../data/sokobano/Large Test Suite";
  let fns = [
    "Aymeric_Du_Peloux_282.xsb",
    "Grigr2001_100.xsb",
    "Grigr2002_40.xsb",
    "GrigrSpecial_40.xsb",
    "Holland_81.xsb",
    "Microban_155.xsb",
    "Microban II_135.xsb",
    "Sasquatch_50.xsb",
    "Sasquatch II_50.xsb",
    "Sasquatch_III_50.xsb",
    "Sasquatch_IV_50.xsb",
    "Sasquatch_V_50.xsb",
    "Sasquatch_VI_50.xsb",
    "Sasquatch_VII_50.xsb",
    "SokEvo_107.xsb",
    "SokHard_163.xsb",
    "Sven_1623.xsb",
    "XSokoban_90.xsb",
    "Yoshio_Murase_Autogenerated_52.xsb",
    "Yoshio Murase_Handmade_54.xsb"
  ];

  let data = {};

  for (let fn_idx in fns) {
    let fn = base_dir + "/" + fns[fn_idx];
    let level_lib = read_xsb(fn);

    let name = fn;
    name = name.replace( /\.xsb/, '' );
    name = name.replace( /^.*\//, '' );

    data[name] = level_lib;
  }

  console.log( JSON.stringify(data) );
}

main();

